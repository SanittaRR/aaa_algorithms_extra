# aaa_algorithms_extra

## Описание сложности и алгоритма решения

### Задача 1
Условие: Порядковая статистика.

Дан массив целых чисел arr и целое число k. 
Нужно найти элемент, который в отсортированном по возрастанию массиве лежит на k-ой позиции.

Алгоритм решения: 
1) Определяются функции max_heapify(arr, i) (восстановление свойства кучи для узла i) и build_max_heap(arr) (построение
кучи из массива) аналогично алгоритму, рассмотренному на семинаре. 
2) Используя данные функции, создать max_heap из изначального массива. 
3) С помощью heapq._heappop_max(arr) извлекается корневой (максимальный) элемент (len(arr) - k - 1) раз и тогда следующий
элемент будет искомым k-ым элементом в списке отсортированном по возрастанию.

Сложность:
1) build_max_heap(arr) - линейная сложность O(N), где N - количество элементов в массиве
2) Затем для (N - k) элементов выполняется функция heapq._heappop_max(arr) сложностью O(logN) => сложность = O((N-k)logN)

Итого: O(N + (N-k)logN)

### Задача 2
Условие: Слияние K отсортированных массивов.

Даны K отсортированных по возрастанию массивов arrs. 
Нужно получить массив, который содержит все элементы из этих массивов и тоже отсортирован по возрастанию. 
Сортировку использовать запрещено. heapq.merge тоже, но можно почитать код для вдохновения. 
Если хотите использовать кучу, то используйте реализацию в модуле heapq, 
самописная реализация на питоне будет медленней и может не пройти тесты.

Алгоритм решения: 
1) Создаем два списка: один для финального массива (total), другой - для временного хранения элементов (heap).
2) Используя heapq.heappush, заполняем массив heap первыми элементами всех K отсортированных массивов, 
то есть их наименьшими элементами. При этом одновременно записывается номер самого отсортированного массива 
и порядок элемента (0).
3) Пока массив heap не будет опустошен: 
Вытаскиваем из heap наименьшее значение, которое будет являться корнем кучи, с помощью heapq.heappop.
И складываем полученное значение в итоговый массив total.
После проверяем, являлся ли данный элемент последним в массиве, которому он принадлежал.
Если нет, то добавляем в heap следующий элемент данного массива.
Затем повторяем действия из пункта 3.
4) Возвращаем массив total.

Сложность:

Во втором пункте алгоритма мы проходим по первым K элементам массивов, выполняя для них функцию heapq.heappush() 
сложностью O(logK).

(3) пункт проходит по всем оставшимся элементам, количество которых обозначим N-K, 
где N - суммарное количество всех элементов. 
И при этом для каждого элемента выполняются поиск, извлечение и вставка сложностью O(logK).

Все остальные операции проходят за константу.

Итого, сложность: O((K + (N-K))*logK) или O(N*logK)
